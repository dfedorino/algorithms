package com.dfedorino.rtasks.second_level;

public class ExplosionHazardTwo {
    /**
     * При переработке радиоактивных материалов образуются отходы трех видов —
     * особо опасные (тип A), неопасные (тип B) и совсем не опасные (тип C).
     * Для их хранения используются одинаковые контейнеры. После помещения отходов
     * в контейнеры последние укладываются вертикальной стопкой.
     * Стопка считается взрывоопасной, если в ней подряд идет более одного контейнера типа A.
     * Стопка считается безопасной, если она не является взрывоопасной.
     * Для заданного количества контейнеров N определить число безопасных стопок.
     * <p>
     * Входные данные
     * Одно число 1 ≤ N ≤ 20.
     * <p>
     * Выходные данные
     * Одно число — количество безопасных вариантов формирования стопки.
     * <p>
     * Примечание
     * В примере из условия среди стопок длины 2 бывают безопасные стопки типов AB, AC, BA, BB, BC, CA, CB и CC.
     * Стопки типа AA являются взрывоопасными.
     * <p>
     * Ход размышлений:
     * 1. разбиваем задачу на простейшие подзадачи:
     * Дана длина стопки N. Такая стопка может заканчиваться только 4-мя возможными безопасными вариантами:
     * 1.1   [..., 0] - в таком случае все безопасные комбинации длины n - 1 подходят;
     * 1.2   [..., 1] - в таком случае не все комбинации длины n - 1 подходят:
     * 1.2.1 [..., 0, 1] - в таком случае подходят все безопасные комбинации n - 2;
     * 1.2.2 [..., 1, 1] - все возможные комбинации опасны;
     * 1.3   [..., 2, 1] - в таком случае подходят все безопасные комбинации n - 2;
     * 1.3   [..., 2] - в таком случае все безопасные комбинации длины n - 1 подходят;
     * 1.4   таким образом найдены все возможные безопасные комбинации для длины n: f(n) = 2 * (f(n - 1) + f(n - 2));
     * 2.    какой длиной может закончиться любая длина n?
     * 2.1   n = 0, f(0) = 0;
     * 2.2   n = 1, f(1) = 3;
     * 2.2   n = 2, f(2) = 8;
     * 2.3   n = 3, f(3) = 2 * (f(2) + f(1));
     *
     * @param containers - число 1 ≤ N ≤ 20.
     * @return количество безопасных вариантов формирования стопки
     */
    public int getNumberOfSafeStacks(int containers) {
        int[] stacks = new int[containers + 1];
        for (int height = 1; height < stacks.length; height++) {
            switch (height) {
                case 1:
                    stacks[1] = 3;
                    break;
                case 2:
                    stacks[2] = 8;
                    break;
                default:
                    stacks[height] = 2 * (stacks[height - 1] + stacks[height - 2]);
            }
        }
        return stacks[containers];
    }
}
