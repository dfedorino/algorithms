package com.dfedorino.rtasks.second_level;

public class PaidLadder {
    /**
     * Мальчик подошел к платной лестнице.
     * Чтобы наступить на любую ступеньку, нужно заплатить указанную на ней сумму.
     * Мальчик умеет перешагивать на следующую ступеньку, либо перепрыгивать через ступеньку.
     * Требуется узнать, какая наименьшая сумма понадобится мальчику, чтобы добраться до верхней ступеньки.
     * <p>
     * Входные данные
     * В первой строке входного файла вводится одно натуральное число N ≤ 100 — количество ступенек.
     * В следующей строке вводятся N натуральных чисел, не превосходящих 100 — стоимость каждой ступеньки (снизу вверх).
     * <p>
     * Выходные данные
     * Выведите одно число — наименьшую возможную стоимость прохода по лесенке.
     * <p>
     * Ход размышлений (новый подход):
     * 0.  Основная задача - понять, какой из всех возможных путей самый дешевый;
     * <p>
     * 1.  Решить задачу для маленьких ограничений:
     * 1.1 {} -> мин. стоимость = 0, т.е. f(0) = 0;
     * 1.2 {1} -> мин. стоимость = 1, так как мальчик сразу доберется до последней ступеньки, т.е. f(1) = prices[0];
     * 1.3 {10, 1} -> мин. стоимость = 1, так как мальчик умеет перешагивать через ступеньку, т.е. f(2) = prices[1];
     * 1.4 {1, 10, 1} -> мин. стоимость = 2, так как к стоимости последней ступеньки прибавляется цена последней ступеньки;
     * 1.4 т.е. f(3) = prices[2] + Math.min(f(2), f(1));
     * <p>
     * 2.  Найти решение для лестницы длины n:
     * 2.1 Стоимость последней ступеньки всегда будет учитываться в итоговой сумме;
     * 2.2 К последней ступеньке можно прийти (n - 1) + (n - 2) возможными способами;
     * 2.3 Возможные минимальные суммы до ступеньки n - это либо f(n - 1), либо f(n - 2);
     * 2.4 Реккурентная формула f(n) = prices[n - 1] + f(n - 1) + f(n - 2);
     *
     * @param prices - стоимости ступенек
     * @return наименьшая возможная стоимость прохода по лесенке.
     */
    public int getLeastSum(int[] prices) {
        int[] sums = new int[prices.length + 1];
        for (int steps = 1; steps < sums.length; steps++) {
            if (steps == 1) {
                sums[1] = prices[0];
            } else if (steps == 2) {
                sums[2] = prices[1];
            } else {
                sums[steps] = prices[steps - 1] + Math.min(sums[steps - 1], sums[steps - 2]);
            }
        }
        return sums[prices.length];
    }
}
